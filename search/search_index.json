{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyconject","text":"<p><code>pyconject</code> is a (highly) opinionated PYthon CONfig inJECTor library inspired by Spring Framework (and Spring Boot Framework).</p> <p>How to pronounce <code>pyconject</code></p> <p><code>pyconject</code> is pronounced PY-CON-JECT, a word play for Burmese \"\u1015\u102d\u102f\u1000\u103a\u1000\u103d\u1014\u103a\u1001\u103b\u1000\u103a\" = \"the art of throwing net\". It represents how it can be used to capture all types of configs and inject them into all types of packages.</p>"},{"location":"#usage","title":"Usage","text":"<p>For detailed usage, refer to usage.</p>"},{"location":"#tldr","title":"TL;DR","text":"<p>Instead of this: </p> <pre><code># in usr_p/usr_sp/usr_m.py\nfrom black_p.black_sp.black_m import black_func\n\n# initialize values_a, value_b, value_c and value_d.\n# this part is often the ugly mess because it involves \n# reading yaml or other tree-like files and assigning values\nimport yaml\nwith open(\"./configs.yml\", \"rt\") as f:\n  configs = yaml.safe_load(f)\n  black_func_parameters = configs[\"black_p\"][\"black_sp\"][\"black_m\"][\"black_func\"]\n  value_a = black_func_parameters[\"a\"]\n  # more ugly things here; you get the gist ...\n\nblack_func(a=value_a, b=value_b, c=value_c, d=value_d)\n</code></pre> <p>With <code>pyconject</code>, we can do this:</p> <pre><code># in usr_p/usr_sp/usr_m.py\nfrom black_p.black_sp.black_m import black_func\n\n# pyconject initializes values of a, b, c and d.\nfrom pyconject import pyconject\n\npyconject.init(globals())\n\nwith pyconject.cntx():\n    black_func() \n</code></pre>"},{"location":"#developing-with-pyconject","title":"Developing with <code>pyconject</code>","text":"<p>Instead of this:</p> <pre><code># in dev_p/dev_sp/dev_m.py\nimport os\n\nenv = os.environ[\"environment\"]\n\ndef dev_func(a=None, b=None, c=None, d=None):\n  if env == \"dev\":\n    if a is None: a = \"dev-a\"\n    if b is None: b = \"dev-b\"\n    # you know the rest\n  elif env == \"stg\":\n    if a is None: a = \"stg-a\"\n    if b is None: b = \"stg-b\"\n    # you know the rest\n  elif env == \"prd\":\n    if a is None: a = \"prd-a\"\n    if b is None: b = \"prd-b\"\n    # you know the rest\n  # ... \n  # your application logic\n  return results\n</code></pre> <p>With <code>pyconject</code>, you can do this:</p> <pre><code># in dev_p/dev_sp/pyconject-dev_m-dev.py\ndev_func:\n  a : \"dev-a\"\n  b : \"dev_b\"\n  ...\n</code></pre> <pre><code># in dev_p/dev_sp/dev_m.py\nfrom pyconject import pyconject\n\n@pyconject.func\ndef dev_func(a, b, c, d):\n  # your application logic\n  return results\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Developer integration</li> <li>Functions</li> <li>Classes</li> <li>Modules </li> <li> <p>Packages </p> </li> <li> <p>Client integration</p> </li> <li>Functions</li> <li>Classes</li> <li>Modules</li> <li>Packages</li> <li> <p>Init (with <code>globals()</code>)</p> </li> <li> <p>Type of configs</p> </li> <li>yaml -- priority<ul> <li>reference other yaml files</li> </ul> </li> <li>environment/target selection</li> </ul>"},{"location":"#to-dos","title":"To Dos","text":"<ul> <li> <p>Generate config files</p> </li> <li> <p>Raw retrieval of resolved configs (to manipulate by user)</p> </li> <li> <p>Other types of configs</p> </li> <li>.env</li> <li>override by<ul> <li>environment variables</li> <li>commandline arguments</li> </ul> </li> </ul>"},{"location":"#how-to-contribute","title":"How to contribute","text":"<ul> <li>Create a PR into <code>dev</code> branch. </li> <li>Github actions will run unit-tests. </li> <li>Periodically, the package maintainer will PR into <code>main</code> branch.</li> <li>Unit-tests will be run again. </li> <li>When merged, pypi package and github releases will be published.</li> </ul>"},{"location":"usage/","title":"Usage","text":"<p><code>pyconject</code> caters two groups of users: </p> <ul> <li>client-users: the clients of the python libraries and </li> <li>dev-users: the developers of these python libraries.</li> </ul>"},{"location":"usage/#1-client-usage","title":"1. Client usage","text":"<p>Beautiful is better than ugly. [PEP-20]</p> <p>Consider the following python script that is using a black box function <code>black_func</code> defined in <code>black_p.black_sp.black_m</code>.</p> <pre><code># in usr_p/usr_sp/usr_m.py\nfrom black_p.black_sp.black_m import black_func\n\n# initialize values_a, value_b, \n# value_c and value_d.\n# this part is often the ugly mess\n# because it involves reading yaml \n# or other tree-like files and \n# assigning values\nimport yaml\nwith open(\"./configs.yml\", \"rt\") as f:\n  configs = yaml.safe_load(f)\n  black_func_parameters = configs[\"black_p\"][\"black_sp\"][\"black_m\"][\"black_func\"]\n  value_a = black_func_parameters[\"a\"]\n  value_b = black_func_parameters[\"b\"]\n  value_c = black_func_parameters[\"c\"]\n  value_d = black_func_parameters[\"d\"]\n\nblack_func(a=value_a, b=value_b, c=value_c, d=value_d)\n</code></pre> <p>We give the content of the <code>configs.yml</code> file as follow for completeness:</p> <pre><code># in ./configs.yml\nblack_p:\n  black_sp:\n    black_m:\n      black_func:\n        a: 1\n        b: 2\n        c: 3\n        d: 4\n</code></pre> <p>Imagine this script needs to initialize a lot of variables such as <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> for the likes of <code>black_func</code>. This will overwhelm the client users and makes the script code ugly.</p>"},{"location":"usage/#11-default-usage","title":"1.1. Default usage","text":"<p><code>pyconject</code> allows a client user to define a yaml file to inject the variable values as follow: </p> <pre><code># in usr_p/usr_sp/usr_m.py\nfrom black_p.black_sp.black_m import black_func\n\n# pyconject initializes values of a, b, c and d.\nfrom pyconject import pyconject\n\npyconject.init(globals())\n\nwith pyconject.cntx():\n    black_func() \n</code></pre> <p>Notice, there needs just 3 lines of code to let <code>pyconject</code> inject the configs defined in the current working directory:</p> <ol> <li>importing pyconject: <code>from pyconject import pyconject</code></li> <li>letting <code>pyconject</code> knows that it needs to manage <code>globals()</code> dictionary: <code>pyconject.init(globals())</code></li> <li>running <code>black_func</code> in the <code>pyconject</code> context: <code>with pyconject.cntx():</code></li> </ol> <p>In this specific example, <code>pyconject</code> will inject a=1, b=2, c=3 and d=4 into the running script.</p>"},{"location":"usage/#12-target-smart-features","title":"1.2. <code>target</code> smart features","text":"<p><code>pyconject</code> is aware of the fact that many user scripts need to use different configurations for different environment. By default, <code>pyconject</code> supports 3 <code>target</code>s:</p> <ul> <li><code>dev</code> for development</li> <li><code>stg</code> for staging and</li> <li><code>prd</code> for production</li> </ul> <p>In the above running example, user simply needs to append <code>-&lt;target&gt;</code> in the stem of the config file names to let <code>pyconject</code> chooses <code>target</code>-specific configs file.</p> <pre><code># in ./configs-dev.yml\nblack_p:\n  black_sp:\n    black_m:\n      black_func:\n        c: 30\n        d: 40\n</code></pre> <pre><code># in usr_p/usr_sp/usr_m.py\nfrom black_p.black_sp.black_m import black_func\n\n# initialize values of a, b, c and d.\nfrom pyconject import pyconject\n\npyconject.init(globals())\n\nwith pyconject.cntx(target=\"dev\"):\n    black_func(a=a, b=b, c=c, d=d)\n</code></pre> <p>In this way, <code>pyconject</code> will inject a=1 and b=2 as defined in <code>configs.yml</code> and c=30 and d=40 as defined in <code>configs-dev.yml</code>.</p> <p>Notice that <code>pyconject</code> overrides values from <code>configs.yml</code> with values from <code>configs-&lt;target&gt;.yml</code> if a <code>target</code> is specified. </p>"},{"location":"usage/#13-custom-config-file-names","title":"1.3. Custom config file names","text":"<p><code>pyconject</code> also allows client-users to name config files differently and save in arbitrary path. If the client-user creates the following two config files:</p> <pre><code># in /path/to/user/defined/configs/cfg.yml\nblack_p:\n  black_sp:\n    black_m:\n      black_func:\n        a: 1\n        b: 2\n        c: 3\n        d: 4\n</code></pre> <pre><code># in /path/to/user/defined/configs/cfg-dev.yml\nblack_p:\n  black_sp:\n    black_m:\n      black_func:\n        c: 30\n        d: 40\n</code></pre> <pre><code># in usr_p/usr_sp/usr_m.py\nfrom black_p.black_sp.black_m import black_func\n\n# initialize values of a, b, c and d.\nfrom pyconject import pyconject\n\npyconject.init(globals())\n\nwith pyconject.cntx(\n        config_path=\"/path/to/user/defined/configs/cfg.yml\", \n        target=\"dev\"\n    ):\n    black_func(a=a, b=b, c=c, d=d)\n</code></pre> <p><code>pyconject</code> will inject configs in <code>cfg.yml</code> and <code>cfg-dev.yml</code> as a = 1, b = 2, c = 30 and d = 40. </p> <p>Notice that <code>cfg.yml</code> and <code>cfg-dev.yml</code> still needs to be in the same directory with each other.</p>"},{"location":"usage/#2-dev-usage","title":"2. Dev usage","text":"<p>Explicit is better than implicit. [PEP-20]</p> <p>Even though users can initialize <code>pyconject</code> by calling <code>pyconject.init</code> to have parameters injected into any function, it will be better if <code>pyconject</code> allows developer of python libraries to explictly pre-initialize/pre-register their functions (and modules) for the user scripts. </p> <p>In addition, they can define default parameter values and <code>target</code>-specific parameter values. </p> <p>Notice that the user can overwrite these defaults either using <code>pyconject</code> or directly in their code. </p> <p>This is not a new concept <code>pyconject</code> introduces as, from the very beginning, users of libraries can pass any value to any parameter.</p> <p>Consider the following directory tree:</p> <pre><code>dev_p\n\u2502   __init.py\n\u2502\n\u2514\u2500\u2500\u2500dev_sp\n        dev_m.py\n        __init__.py\n</code></pre>"},{"location":"usage/#21-registering-a-module","title":"2.1. Registering a module","text":"<pre><code># in dev_p/dev_sp/dev_m.py\ndef dev_func(a, b, c, d):\n    return a, b, c, d\n</code></pre> <p>To register the <code>dev_p</code> module in <code>pyconject</code>, the developer needs to explicitly register it as follow:</p> <pre><code># in dev_p/__init__.py\nfrom pyconject import pyconject\npyconject.mdle(__name__)\n</code></pre> <p>By default, <code>pyconject</code> will try to find the configurations in this file: <code>dev_p/pyconject.yml</code></p> <pre><code># in dev_p/pyconject.yml\ndev_sp:\n  dev_m: \n    dev_func:\n      a: 101\n      b: 202\n      c: 303\n      d: 404\n</code></pre> <p>Then, <code>pyconject</code> will inject the configs for <code>dev_func</code> as follow: </p> <pre><code>from dev_p.dev_sp.dev_m import dev_func\n# notice client needs not be aware of pyconject here\naa, bb, cc, dd = dev_func()\n\n# this will print 101, 202, 303, 404\nprint (aa, bb, cc, dd) \n</code></pre>"},{"location":"usage/#22-tree-smart-features","title":"2.2. Tree smart features","text":"<p><code>pyconject</code> expects different kinds of <code>yaml</code> trees for client-users and dev-users. More specifically, <code>pyconject</code> understands the configs defined in <code>dev_p/pyconject.yml</code> is for package <code>dev_p</code> (package level configs). That's why <code>dev_p/pyconject.yml</code> tree does not need to specify <code>dev_p</code> like it would require for client-user's <code>configs.yml</code> file.</p> <p>Likewise, <code>pyconject</code> understands the configs defined in <code>dev_p/dev_sp/pyconject.yml</code> is for sub-package <code>dev_p.dev_sp</code> (sub-package level configs). It will look like the followings: </p> <pre><code># in dev_p/dev_sp/pyconject.yml\ndev_m: \n  dev_func:\n    a: 1001\n    b: 2002\n    c: 3003\n</code></pre> <p>Similarly, <code>pyconject</code> understands the configs defined in <code>dev_p/dev_sp/pyconject-dev_m.yml</code> is for module <code>dev_p.dev_sp.dev_m</code> (referred to as module level configs from its name). It will look like the followings:</p> <pre><code># in dev_p/dev_sp/pyconject-dev_m.yml\ndev_func:\n  a: 10001\n  b: 20002\n</code></pre> <p>Finally, <code>pyconject</code> also understands the configs defined in <code>dev_p/dev_sp/pyconject-dev_m-dev_func.yml</code> is for function <code>dev_p.dev_sp.dev_m.dev_func</code> (referred to as function level configs from its name). It will look like the followings:</p> <pre><code># in dev_p/dev_sp/pyconject-dev_m-dev_func.yml\na: 100001\n</code></pre>"},{"location":"usage/#23-target-smart-features","title":"2.3. <code>target</code> smart features","text":"<p>Of course, <code>pyconject</code> also allows dev-users to specify <code>target</code>-specific configs.</p> <p>Non-target specific default configurations can be achieved with ordinary python default parameter values as well such as <code>def dev_func(a, b, c=333, d=444):</code>.</p> <p>To define <code>target</code>-specific configs, just append <code>-&lt;target&gt;</code> in the stem of the filename of the respective configs. For example,</p> <ul> <li><code>dev_p/pyconject-dev.yml</code></li> <li><code>dev_p/dev_sp/pyconject-stg.yml</code></li> <li><code>dev_p/dev_sp/pyconject-dev_m-prd.yml</code></li> </ul> <p>The specific <code>target</code> names are in the contract between developer and client of the respective python library and, hence, out of scope for <code>pyconject</code>. </p> <p>Nonetheless, <code>pyconject</code> recommends to set <code>dev</code>, <code>stg</code> and <code>prd</code>. </p>"},{"location":"usage/#24-custom-config-file-names","title":"2.4. Custom config file names","text":"<p>Like client-users, dev-users can also define custom file names for <code>pyconject</code> configs.</p> <pre><code># in dev_p/dev_sp/dev_m.py\n\nfrom pyconject import pyconject\n\n@pyconject.func\ndef dev_func(a, b, c, d):\n  dev_func.pyconject = \"custom-name.yml\"\n  return a, b, c, d\n\n@pyconject.func\ndef dev_func_target(a, b, c, d):\n  dev_func.pyconject = {\"dev\" : \"custom-dev.yml\", \"stg\" : \"custom-stg.yml\"}\n  return a, b, c, d\n</code></pre> <p>Notice that <code>pyconject</code> still infers the functions (and modules) the configs is supposed to be injected based on the directory structure. Therefore, it is imperative to give the path relative to the respective module file. </p>"},{"location":"usage/#3-resolving-collisions","title":"3. Resolving collisions","text":"<p>If multiple config files specify the same values, <code>pyconject</code> resolves them as follow (higher entry overrides lower entries):</p> <ul> <li>explicitly specifying in <code>python</code> code such as <code>dev_func(a=0.1, b=0.2, c=0.3, d=0.4)</code></li> <li>This is backward-compatibility feature.</li> <li> <p>specified in <code>target</code>-specific configs defined by client-user such as <code>configs-dev.yml</code></p> </li> <li> <p>specified in <code>target</code>-specific function level configs defined by dev-user such as <code>dev_p/dev_sp/pyconject-dev_m-dev_func-dev.yml</code></p> </li> <li>specified in <code>target</code>-specific module level configs defined by dev-user such as <code>dev_p/dev_sp/pyconject-dev_m.yml</code></li> <li>specified in <code>target</code>-specific sub-package level configs defined by dev-user such as <code>dev_p/dev_sp/pyconject-dev.yml</code></li> <li>specified in <code>target</code>-specific package level configs defined by dev-user such as <code>dev_p/pyconject-dev.yml</code></li> <li>specified in configs defined by client-user such as <code>configs.yml</code></li> <li>specified in function level configs defined by dev-user such as <code>dev_p/dev_sp/pyconject-dev_m-dev_func.yml</code></li> <li>specified in module level configs defined by dev-user such as <code>dev_p/dev_sp/pyconject-dev_m.yml</code></li> <li>specified in sub-package level configs defined by dev-user such as <code>dev_p/dev_sp/pyconject.yml</code></li> <li>specified in package level configs defined by dev-user such as <code>dev_p/pyconject.yml</code></li> </ul>"},{"location":"usage/#31-example-1","title":"3.1. Example 1:","text":"<p>When there is no client-user configs defined,</p> <pre><code>from dev_p.dev_sp.dev_m import dev_func\n\naa, bb, cc, dd = dev_func()\n\n# this will print 100001, 20002, 3003, 404\nprint (aa, bb, cc, dd) \n</code></pre>"},{"location":"usage/#32-example-2","title":"3.2. Example 2:","text":"<p>When there are client-user configs defined as follow:</p> <pre><code># in ./configs.yml\ndev_p:\n  dev_sp:\n    dev_m:\n      dev_func:\n        a: 0.1\n        b: 0.2\n</code></pre> <p>and</p> <pre><code># in ./configs-dev.yml\ndev_p:\n  dev_sp:\n    dev_m:\n      dev_func:\n        a: 0.01\n</code></pre> <pre><code>from dev_p.dev_sp.dev_m import dev_func\n\nfrom pyconject import pyconject\n\nwith pyconject.cntx(target=\"dev\"): \n    aa, bb, cc, dd = dev_func()\n\n    # this will print 0.01, 0.2, 3003, 404\n    print (aa, bb, cc, dd) \n</code></pre>"}]}